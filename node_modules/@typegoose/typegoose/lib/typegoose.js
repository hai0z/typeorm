"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Passthrough = exports.getDiscriminatorModelForClass = exports.deleteModelWithClass = exports.deleteModel = exports.addModelToTypegoose = exports.buildSchema = exports.getModelWithString = exports.getModelForClass = exports.Severity = exports.getName = exports.getClass = exports.getClassForDocument = exports.types = exports.errors = exports.defaultClasses = exports.LogLevels = exports.setLogLevel = exports.setGlobalOptions = exports.mongoose = void 0;
const tslib_1 = require("tslib");
/* imports */
const mongoose = require("mongoose");
exports.mongoose = mongoose;
require("reflect-metadata");
const semver = require("semver");
const utils_1 = require("./internal/utils");
/* istanbul ignore next */
if (!(0, utils_1.isNullOrUndefined)(process === null || process === void 0 ? void 0 : process.version) && !(0, utils_1.isNullOrUndefined)(mongoose === null || mongoose === void 0 ? void 0 : mongoose.version)) {
    // for usage on client side
    /* istanbul ignore next */
    if (semver.lt(mongoose === null || mongoose === void 0 ? void 0 : mongoose.version, '6.0.11')) {
        throw new Error(`Please use mongoose 6.0.11 or higher (Current mongoose: ${mongoose.version}) [E001]`);
    }
    /* istanbul ignore next */
    if (semver.lt(process.version.slice(1), '12.22.0')) {
        throw new Error('You are using a NodeJS Version below 12.22.0, Please Upgrade! [E002]');
    }
}
const globalOptions_1 = require("./globalOptions");
Object.defineProperty(exports, "setGlobalOptions", { enumerable: true, get: function () { return globalOptions_1.setGlobalOptions; } });
const constants_1 = require("./internal/constants");
const data_1 = require("./internal/data");
const schema_1 = require("./internal/schema");
const logSettings_1 = require("./logSettings");
const typeguards_1 = require("./typeguards");
const errors_1 = require("./internal/errors");
var logSettings_2 = require("./logSettings");
Object.defineProperty(exports, "setLogLevel", { enumerable: true, get: function () { return logSettings_2.setLogLevel; } });
Object.defineProperty(exports, "LogLevels", { enumerable: true, get: function () { return logSettings_2.LogLevels; } });
(0, tslib_1.__exportStar)(require("./prop"), exports);
(0, tslib_1.__exportStar)(require("./hooks"), exports);
(0, tslib_1.__exportStar)(require("./plugin"), exports);
(0, tslib_1.__exportStar)(require("./index"), exports);
(0, tslib_1.__exportStar)(require("./modelOptions"), exports);
(0, tslib_1.__exportStar)(require("./queryMethod"), exports);
(0, tslib_1.__exportStar)(require("./typeguards"), exports);
exports.defaultClasses = require("./defaultClasses");
exports.errors = require("./internal/errors");
exports.types = require("./types");
var utils_2 = require("./internal/utils");
Object.defineProperty(exports, "getClassForDocument", { enumerable: true, get: function () { return utils_2.getClassForDocument; } });
Object.defineProperty(exports, "getClass", { enumerable: true, get: function () { return utils_2.getClass; } });
Object.defineProperty(exports, "getName", { enumerable: true, get: function () { return utils_2.getName; } });
var constants_2 = require("./internal/constants");
Object.defineProperty(exports, "Severity", { enumerable: true, get: function () { return constants_2.Severity; } });
(0, globalOptions_1.parseENV)(); // call this before anything to ensure they are applied
/**
 * Get a Model for a Class
 * @param cl The uninitialized Class
 * @returns The Model
 * @public
 * @example
 * ```ts
 * class ClassName {}
 *
 * const NameModel = getModelForClass(ClassName);
 * ```
 */
function getModelForClass(cl, options) {
    var _a, _b, _c, _d, _e, _f;
    (0, utils_1.assertionIsClass)(cl);
    options = typeof options === 'object' ? options : {};
    const roptions = (0, utils_1.mergeMetadata)(constants_1.DecoratorKeys.ModelOptions, options, cl);
    const name = (0, utils_1.getName)(cl, options);
    if (data_1.models.has(name)) {
        return data_1.models.get(name);
    }
    const model = (_d = (_b = (_a = roptions === null || roptions === void 0 ? void 0 : roptions.existingConnection) === null || _a === void 0 ? void 0 : _a.model.bind(roptions.existingConnection)) !== null && _b !== void 0 ? _b : (_c = roptions === null || roptions === void 0 ? void 0 : roptions.existingMongoose) === null || _c === void 0 ? void 0 : _c.model.bind(roptions.existingMongoose)) !== null && _d !== void 0 ? _d : mongoose.model.bind(mongoose);
    const compiledmodel = model(name, buildSchema(cl, roptions.schemaOptions, options));
    const refetchedOptions = (_e = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, cl)) !== null && _e !== void 0 ? _e : {};
    if ((_f = refetchedOptions === null || refetchedOptions === void 0 ? void 0 : refetchedOptions.options) === null || _f === void 0 ? void 0 : _f.runSyncIndexes) {
        // no async/await, to wait for execution on connection in the background
        compiledmodel.syncIndexes();
    }
    return addModelToTypegoose(compiledmodel, cl, {
        existingMongoose: roptions === null || roptions === void 0 ? void 0 : roptions.existingMongoose,
        existingConnection: roptions === null || roptions === void 0 ? void 0 : roptions.existingConnection,
    });
}
exports.getModelForClass = getModelForClass;
/**
 * Get Model from internal cache
 * @param key ModelName key
 * @example
 * ```ts
 * class ClassName {}
 * getModelForClass(ClassName); // build the model
 * const NameModel = getModelWithString<typeof ClassName>("ClassName");
 * ```
 */
function getModelWithString(key) {
    (0, utils_1.assertion)(typeof key === 'string', TypeError(`Expected "key" to be a string, got "${key}"`));
    return data_1.models.get(key);
}
exports.getModelWithString = getModelWithString;
/**
 * Generates a Mongoose schema out of class props, iterating through all parents
 * @param cl The not initialized Class
 * @returns Returns the Build Schema
 * @example
 * ```ts
 * class ClassName {}
 * const NameSchema = buildSchema(ClassName);
 * const NameModel = mongoose.model("Name", NameSchema);
 * ```
 */
function buildSchema(cl, options, overwriteOptions) {
    (0, utils_1.assertionIsClass)(cl);
    logSettings_1.logger.debug('buildSchema called for "%s"', (0, utils_1.getName)(cl, overwriteOptions));
    const mergedOptions = (0, utils_1.mergeSchemaOptions)(options, cl);
    let sch = undefined;
    /** Parent Constructor */
    let parentCtor = Object.getPrototypeOf(cl.prototype).constructor;
    /* This array is to execute from lowest class to highest (when extending) */
    const parentClasses = [];
    // iterate trough all parents
    while ((parentCtor === null || parentCtor === void 0 ? void 0 : parentCtor.name) !== 'Object') {
        // add lower classes (when extending) to the front of the arrray to be processed first
        parentClasses.unshift(parentCtor);
        // set next parent
        parentCtor = Object.getPrototypeOf(parentCtor.prototype).constructor;
    }
    // iterate and build class schemas from lowest to highest (when extending classes, the lower class will get build first) see https://github.com/typegoose/typegoose/pull/243
    for (const parentClass of parentClasses) {
        // extend schema
        sch = (0, schema_1._buildSchema)(parentClass, sch, mergedOptions, false);
    }
    // get schema of current model
    sch = (0, schema_1._buildSchema)(cl, sch, mergedOptions, true, overwriteOptions);
    return sch;
}
exports.buildSchema = buildSchema;
/**
 * This can be used to add custom Models to Typegoose, with the type information of cl
 * Note: no gurantee that the type information is fully correct
 * @param model The model to store
 * @param cl The Class to store
 * @param options? Optional param for existingMongoose or existingConnection
 * @example
 * ```ts
 * class ClassName {}
 *
 * const schema = buildSchema(ClassName);
 * // modifications to the schame can be done
 * const model = addModelToTypegoose(mongoose.model("Name", schema), ClassName);
 * ```
 */
function addModelToTypegoose(model, cl, options) {
    var _a, _b, _c;
    const mongooseModel = ((_a = options === null || options === void 0 ? void 0 : options.existingMongoose) === null || _a === void 0 ? void 0 : _a.Model) || ((_c = (_b = options === null || options === void 0 ? void 0 : options.existingConnection) === null || _b === void 0 ? void 0 : _b.base) === null || _c === void 0 ? void 0 : _c.Model) || mongoose.Model;
    (0, utils_1.assertion)(model.prototype instanceof mongooseModel, new errors_1.NotValidModelError(model, 'addModelToTypegoose.model'));
    (0, utils_1.assertionIsClass)(cl);
    const name = model.modelName;
    (0, utils_1.assertion)(!data_1.models.has(name), new errors_1.FunctionCalledMoreThanSupportedError('addModelToTypegoose', 1, `This was caused because the model name "${name}" already exists in the typegoose-internal "models" cache`));
    if (data_1.constructors.get(name)) {
        logSettings_1.logger.info('Class "%s" already existed in the constructors Map', name);
    }
    data_1.models.set(name, model);
    data_1.constructors.set(name, cl);
    return data_1.models.get(name);
}
exports.addModelToTypegoose = addModelToTypegoose;
/**
 * Deletes an existing model so that it can be overwritten with another model
 * (deletes from mongoose.connection & typegoose models cache & typegoose constructors cache)
 * @param key
 * @example
 * ```ts
 * class ClassName {}
 * const NameModel = getModelForClass(ClassName);
 * deleteModel("ClassName");
 * ```
 */
function deleteModel(name) {
    (0, utils_1.assertion)(typeof name === 'string', new TypeError('name is not an string! (deleteModel)'));
    const model = data_1.models.get(name);
    (0, utils_1.assertion)(model, new Error(`Model "${name}" could not be found`));
    logSettings_1.logger.debug('Deleting Model "%s"', name);
    model.db.deleteModel(name);
    data_1.models.delete(name);
    data_1.constructors.delete(name);
}
exports.deleteModel = deleteModel;
/**
 * Delete a model, with the given class
 * Same as "deleteModel", only that it can be done with the class instead of the name
 * @param cl The Class
 * @example
 * ```ts
 * class ClassName {}
 * const NameModel = getModelForClass(ClassName);
 * deleteModelWithClass(ClassName);
 * ```
 */
function deleteModelWithClass(cl) {
    (0, utils_1.assertionIsClass)(cl);
    let name = (0, utils_1.getName)(cl);
    if (!data_1.models.has(name)) {
        logSettings_1.logger.debug(`Class "${name}" is not in "models", trying to find in "constructors"`);
        let found = false;
        // type "Map" does not have a "find" function, and using "get" would maybe result in the incorrect values
        for (const [cname, constructor] of data_1.constructors) {
            if (constructor === cl) {
                logSettings_1.logger.debug(`Found Class in "constructors" with class name "${name}" and entered name "${cname}""`);
                name = cname;
                found = true;
            }
        }
        if (!found) {
            logSettings_1.logger.debug(`Could not find class "${name}" in constructors`);
            return;
        }
    }
    return deleteModel(name);
}
exports.deleteModelWithClass = deleteModelWithClass;
/**
 * Build a Model from a given class and return the model
 * @param from The Model to build From
 * @param cl The Class to make a model out
 * @param value The Identifier to use to differentiate documents (default: cl.name)
 * @example
 * ```ts
 * class Class1 {}
 * class Class2 extends Class1 {}
 *
 * const Class1Model = getModelForClass(Class1);
 * const Class2Model = getDiscriminatorModelForClass(Class1Model, Class1);
 * ```
 */
function getDiscriminatorModelForClass(from, cl, value) {
    (0, utils_1.assertion)((0, typeguards_1.isModel)(from), new errors_1.NotValidModelError(from, 'getDiscriminatorModelForClass.from'));
    (0, utils_1.assertionIsClass)(cl);
    const name = (0, utils_1.getName)(cl);
    if (data_1.models.has(name)) {
        return data_1.models.get(name);
    }
    const sch = buildSchema(cl);
    const discriminatorKey = sch.get('discriminatorKey');
    if (!!discriminatorKey && sch.path(discriminatorKey)) {
        sch.paths[discriminatorKey].options.$skipDiscriminatorCheck = true;
    }
    const model = from.discriminator(name, sch, value ? value : name);
    return addModelToTypegoose(model, cl);
}
exports.getDiscriminatorModelForClass = getDiscriminatorModelForClass;
/**
 * Use this class if raw mongoose for this path is wanted
 * It is still recommended to use the typegoose classes directly
 * @see Using `Passthrough`, the paths created will also result as an `Schema` (since mongoose 6.0), see {@link https://github.com/Automattic/mongoose/issues/7181 Mongoose#7181}
 * @example
 * ```ts
 * class Dummy {
 *   @prop({ type: () => new Passthrough({ somePath: String }) })
 *   public somepath: { somePath: string };
 * }
 *
 * class Dummy {
 *   @prop({ type: () => new Passthrough({ somePath: String }, true) })
 *   public somepath: { somePath: string };
 * }
 * ```
 */
class Passthrough {
    /**
     * Use this like `new mongoose.Schema()`
     * @param raw The Schema definition
     * @param direct Directly insert "raw", instead of using "type" (this will not apply any other inner options)
     */
    constructor(raw, direct) {
        this.raw = raw;
        this.direct = direct !== null && direct !== void 0 ? direct : false;
    }
}
exports.Passthrough = Passthrough;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZWdvb3NlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3R5cGVnb29zZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsYUFBYTtBQUNiLHFDQUFxQztBQThCNUIsNEJBQVE7QUE3QmpCLDRCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakMsNENBQThIO0FBRTlILDBCQUEwQjtBQUMxQixJQUFJLENBQUMsSUFBQSx5QkFBaUIsRUFBQyxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFBLHlCQUFpQixFQUFDLFFBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FBRSxPQUFPLENBQUMsRUFBRTtJQUNqRiwyQkFBMkI7SUFDM0IsMEJBQTBCO0lBQzFCLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxRQUFRLGFBQVIsUUFBUSx1QkFBUixRQUFRLENBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxFQUFFO1FBQzFDLE1BQU0sSUFBSSxLQUFLLENBQUMsMkRBQTJELFFBQVEsQ0FBQyxPQUFPLFVBQVUsQ0FBQyxDQUFDO0tBQ3hHO0lBRUQsMEJBQTBCO0lBQzFCLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsRUFBRTtRQUNsRCxNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7S0FDekY7Q0FDRjtBQUVELG1EQUE2RDtBQVcxQyxpR0FYQSxnQ0FBZ0IsT0FXQTtBQVZuQyxvREFBcUQ7QUFDckQsMENBQXVEO0FBQ3ZELDhDQUFpRDtBQUNqRCwrQ0FBdUM7QUFDdkMsNkNBQXVDO0FBRXZDLDhDQUE2RjtBQUs3Riw2Q0FBdUQ7QUFBOUMsMEdBQUEsV0FBVyxPQUFBO0FBQUUsd0dBQUEsU0FBUyxPQUFBO0FBQy9CLHNEQUF1QjtBQUN2Qix1REFBd0I7QUFDeEIsd0RBQXlCO0FBQ3pC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